# テスト方針設計

## 1. テスト規模（small/medium/large）

テストは、テスト対象のスコープや依存関係の範囲に応じて、small, medium, largeの3つの規模に分類して実施します。これにより、テストの粒度に関する共通認識を醸成し、円滑なコミュニケーションを支援します。

### smallテスト (単一コンポーネント/モジュールレベル)

- **定義**: 単一の実行プロセス内で完結し、外部依存を極力排除またはモック化した、小規模かつ高速に実行可能なテスト。主に個別の関数、クラス、UIコンポーネントの単体動作、またはAPIエンドポイントの単体ロジックを検証します。
- **目的**: 個々の構成要素が設計通りに正しく機能することを確認する。
- **テスト方針**: 特定のモジュール、関数、またはUIコンポーネントの内部ロジックや表示、インタラクションに焦点を当てます。副作用を管理しやすく、独立して検証可能な単位を対象とします。
- **使用ツール**:
  - `Vitest`: JavaScript/TypeScriptの関数、クラスの単体テスト。Vueコンポーネントの単体テスト（Vue Test Utilsと連携）。
  - `Storybook`: UIコンポーネントのインタラクションテスト（`@storybook/addon-interactions` を使用）。
- **該当するテスト**: ユニットテスト、UIコンポーネント単体テスト（インタラクションテスト含む）。

### mediumテスト (複数コンポーネント/モジュール連携レベル)

- **定義**: 単一のマシン上で実行可能だが、複数のモジュール、サービス、またはプロセス（例: フロントエンドとモックバックエンド、ローカル開発サーバーで動作する限定的なフルスタック環境）が連携する動作を検証する中規模なテスト。
- **目的**: 複数の構成要素が連携した際に、期待通りにデータフローやインタラクションが機能することを確認する。
- **テスト方針**: モジュール間、サービス間のインターフェースやデータ交換、UIコンポーネント群の視覚的一貫性などを検証します。依存関係は一部モック化しつつも、主要な連携部分は実際に動作させて確認します。
- **使用ツール**:
  - `Vitest`: バックエンドにおける複数モジュール間の結合テスト（例: サービス層とリポジトリ層の連携）。
  - `Storybook` と `reg-cli` (または同様の差分比較ツール): UIコンポーネントのビジュアルリグレッションテスト（VRT）。
  - `AWS CDK (スナップショットテスト)`: インフラストラクチャ定義（スタック全体や主要なConstruct群）の構造的な整合性を検証（後のセクションで詳細）。
- **該当するテスト**: 結合テスト、ビジュアルリグレッションテスト（VRT）、インフラ定義スナップショットテスト（スタックレベル）。状況により、限定的なシナリオの手動E2Eテストも含む場合がある。

### largeテスト (システム全体/外部連携レベル)

- **定義**: 実際の運用環境に近い形で、複数のマシンや外部サービス連携を含むシステム全体の主要なワークフローを検証する大規模なテスト。
- **目的**: エンドユーザーの視点からシステム全体が要求仕様を満たしていること、非機能要件（パフォーマンス、負荷耐性など）が基準を満たしていることを確認する。
- **テスト方針**: 主要なユーザーストーリーに基づいたシナリオテスト（主に手動）、実環境に近い条件下でのパフォーマンステストや負荷テストを実施します。外部サービスの実際の挙動もテスト範囲に含める場合があります。
- **使用ツール**:
  - 主に手動によるE2Eテスト。
  - `k6` (または同様の負荷テストツール): パフォーマンステスト、負荷テスト。
  - `AWS CloudWatch`: テスト中のシステムメトリクス監視。
  - `Docker Compose`: 複数の依存サービスを含むテスト環境の構築支援。
- **該当するテスト**: フルスタックE2Eテスト（主に手動）、パフォーマンステスト、負荷テスト、障害復旧テスト（部分的に）、セキュリティテスト（部分的に）。

## 2. テスト自動化

### テスト自動化のメリット

- **効率化**: 手動で行うよりも迅速にテストを実行できるため、開発サイクルが短縮されます。
- **一貫性**: テストの実行において人為的ミスを減らし、常に一貫した結果を得られます。
- **早期の不具合発見**: 開発の早い段階で自動テストを継続的に実行することで、不具合を早期に発見し、修正コストを低減できます。
- **回帰テストの容易化**: 新しいコード変更が既存の機能に意図しない影響（デグレード）を与えていないかを効率的に確認できます。

### テスト自動化を行う際の留意点

- **テスト対象の選定とカバレッジ**:
  - 全てのコードパスを自動テストで網羅することは現実的でない場合が多いため、**コアとなる重要な機能、複雑なロジックを持つ箇所、頻繁に変更が入るが故にデグレードが懸念される箇所**に優先的に自動テストを導入します。
  - カバレッジ目標を設定することも有効ですが、数値だけを追うのではなく、ビジネスリスクや変更頻度を考慮してテスト対象を選定することが重要です。
- **テストの安定性と保守性**:
  - テストは決定論的（同じ入力に対して常に同じ結果を返す）であるべきです。外部要因（時刻、乱数、不安定な外部APIなど）に依存するテストは、モックやスタブを活用して安定させます。
  - UIの構造変更や仕様変更に弱い脆い（brittle）テストは、保守コストを増大させます。テストのセレクタ戦略（例: `data-testid`属性の利用）や、テスト対象の凝集度を高める設計を意識します。
  - **開発初期段階や仕様が流動的な機能**に対する詳細すぎる自動テストは、頻繁な修正が必要となり費用対効果が悪いため、安定してから拡充するなど段階的な導入を検討します。
- **実行時間とフィードバックサイクル**:
  - テストスイート全体の実行時間が長くなりすぎると、開発のフィードバックサイクルが遅延します。テストの規模（small/medium/large）を意識し、CIパイプラインで適切なタイミング（例: プルリクエスト時、マージ時）で実行するテストを分けるなど、実行効率も考慮します。

## 3. 主なテストツール

本プロジェクトで利用を想定している主なテストツールは以下の通りです。各ツールの具体的な適用範囲や目的は「4. テストのスコープ」で詳述します。

### フロントエンド

- **`Vitest`**: 高速な単体テストおよびコンポーネントテストランナー。
- **`Vue Test Utils`**: Vueコンポーネントのテストを支援する公式ユーティリティライブラリ。Vitestと組み合わせて使用。
- **`Storybook`**: UIコンポーネントの開発・ドキュメンテーション・テスト（インタラクションテスト、VRTのベースとして）を行うための分離環境。
- **`Playwright`**: (補助ツールとして) E2Eテストシナリオの手動実行を支援。テストケースの再現手順の記録、要素の特定、部分的な操作の自動化などに限定的に利用を検討。本格的な自動テストスイートとしての利用は慎重に判断。
- **`reg-cli`** (または類似ツール): Storybookと連携し、画像の差分比較によるVRTを実現するツール。

### バックエンド

- **`Vitest`**: Node.js環境での単体テストおよび統合テストランナー。
- **`AWS CDK (Assertion Library)`**: CDKによって定義されるインフラストラクチャの構造を検証するためのアサーション機能（スナップショットテスト含む）。

## 4. テストのスコープと適用ツール

各テストスコープの定義、目的、および主に使用するツールは以下の通りです。テスト規模は「1. テスト規模」の分類に基づきます。

### ユニットテスト

- **テスト規模**: Small
- **目的**: 個別の関数、メソッド、クラス、UIコンポーネントの最小単位のロジックが正しく動作することを確認する。
- **適用範囲**:
  - フロントエンド: Vueコンポーネントのメソッド、算出プロパティ、イベント発行ロジック。コンポーザブル関数、ユーティリティ関数。状態管理ストアのミューテーションやアクション（ロジック部分）。
  - バックエンド: 個別のLambda関数内のヘルパー関数、ビジネスクラスのメソッド、ユーティリティ関数。
- **使用ツール**:
  - フロントエンド: `Vitest`, `Vue Test Utils`
  - バックエンド: `Vitest`
- **備考**: 外部依存（API呼び出し、DBアクセス、他モジュールなど）はモック化またはスタブ化して、テスト対象のロジックに集中します。

### UIコンポーネントテスト (インタラクションテスト含む)

- **テスト規模**: Small
- **目的**: UIコンポーネントがユーザーの操作（クリック、入力など）に対して期待通りに反応し、表示が変化することを確認する。
- **適用範囲**: フロントエンドのVueコンポーネント。
- **使用ツール**: `Storybook` (`@storybook/addon-interactions`, `play`関数を使用), `Vitest` と `Vue Test Utils` (インタラクションを伴うテストも含む)
- **備考**: コンポーネントを分離した環境でテストし、インタラクションの結果としてのイベント発行や状態変化を検証します。

### 結合テスト

- **テスト規模**: Medium
- **目的**: 複数のモジュールやコンポーネント、サービスが連携した際に、インターフェース間のデータの受け渡しや処理フローが正しく機能することを確認する。
- **適用範囲**:
  - フロントエンド: 複数のUIコンポーネントが連携する機能（例: フォーム入力とバリデーション表示）、状態管理ストアとコンポーネントの連携。
  - バックエンド: APIエンドポイントの処理とサービス層・リポジトリ層（モックDB使用など）の連携。複数のLambda関数が間接的に連携するシナリオ（イベント経由など）。
- **使用ツール**:
  - フロントエンド: `Vitest` と `Vue Test Utils` (複数コンポーネントを組み合わせたテスト), `Playwright` (モックAPIを使用したフロントエンド内の機能連携テスト)
  - バックエンド: `Vitest` (モックやインメモリDBを使用したサービス間の連携テスト)
- **備考**: ユニットテストよりも範囲を広げ、モジュール間の「契約」が守られているかを重視します。

### E2E (End-to-End) テスト

- **テスト規模**: Large (主に手動実行)
  - ※ 限定的な範囲や安定したコア機能については、Medium規模での自動化も将来的に検討しうる。
- **目的**: ユーザーの視点から、アプリケーション全体の主要な機能やワークフローが、フロントエンドからバックエンド（および必要に応じて外部サービス）までを通して正しく動作することを確認する。
- **適用範囲**:
  - 主要なユーザーストーリーに基づいたシナリオ。
  - ユーザー登録、ログイン、主要機能の利用、データ永続化など、システム全体のクリティカルパス。
- **使用ツール**:
  - 主に手動テスト。
  - (補助ツールとして) `Playwright`: テストケースの再現手順の記録、要素の特定、部分的な操作の自動化などに限定的に利用を検討。本格的な自動テストスイートとしての利用は、費用対効果を慎重に評価した上で判断する。
- **備考**:
  - 開発初期段階や仕様変更が頻繁な機能、複雑な外部依存を持つシナリオについては、自動化のメンテナンスコストが高くなる傾向があるため、手動による探索的テストやシナリオベースのテストを重視する。
  - 自動化を導入する際は、テストの安定性、実行時間、保守性を十分に考慮し、ROI（投資対効果）が見込める範囲から段階的に進める。
  - テストデータの準備や、本番に近いテスト環境の維持管理が重要になる。

### インフラ定義スナップショットテスト

- **テスト規模**: Medium
- **目的**: AWS CDKによって定義されるインフラストラクチャの構成が、意図した状態（リソースの種類、プロパティ、リソース間の関連など）であることを確認し、意図しない変更を検知する。
- **適用範囲**: バックエンドのAWS CDKスタック定義。
- **使用ツール**: `AWS CDK (Assertion Library)` のスナップショット機能および各種アサーションメソッド。
- **備考**: これはコードとしてのインフラ(IaC)のテストであり、インフラがデプロイ後に期待通りに機能するかをテストするものではありません（機能テストはE2Eテストや結合テストの範疇）。「5. テスト結果の定義と構造化」で詳述。

### VRT (ビジュアルリグレッションテスト)

- **テスト規模**: Medium
- **目的**: UIコンポーネントやページの見た目が、以前のバージョンから意図せず変更されていないか（デグレードしていないか）を画像比較によって自動的に検知する。
- **適用範囲**: フロントエンドの主要なUIコンポーネントおよびページ。
- **使用ツール**: `Storybook` (スナップショット画像生成のベースとして), `reg-cli` (または `Loki`, `Chromatic` などの専用VRTツール/サービス)
- **備考**: CSSの変更やリファクタリングによる意図しない見た目の変化を効率的に発見できます。適切な差分許容度やテスト対象の選定が重要です。

## 5. テスト結果の定義と構造化

テストがどのような状態で「正しい」と判断するかを客観的かつ明確に定義し、テスト結果を構造化して検証可能にすることが重要です。

### テスト結果の定義基準

テスト結果は以下の基準に基づいて「正しい」と定義します：

1. **明確な期待値の設定**

   - 各テストケースは実行前に具体的な期待値（Expected Value）を明示的に定義する
   - 期待値はコードレビューで確認可能な形で記述する
   - 「正しく作成されている」といった曖昧な表現ではなく、具体的な状態や値を定義する

2. **検証可能な条件**

   - 定性的な評価ではなく、定量的かつ検証可能な条件を設定する
   - 例：「S3バケットが正しく作成されている」ではなく「S3バケットがVersioningEnabledで作成されている」など

3. **決定的なテスト**
   - 同じ条件下で繰り返し実行しても同じ結果が得られること（決定的）
   - 非決定的な要素（タイムスタンプ、乱数など）はモック化または固定値を使用する

### テスト結果の構造化

テスト結果を以下のように構造化して管理します：

1. **カテゴリ分類**

   - 関連するテストケースをグループ化（リソースタイプ、機能単位など）
   - 各カテゴリはドメイン知識に基づいた意味のある単位とする

2. **検証レベルの階層化**

   - プロパティレベル：リソースの個別プロパティが期待通りか
   - リソースレベル：リソース全体の構成が期待通りか
   - スタックレベル：複数リソース間の関係が期待通りか

3. **メトリクス収集**
   - カバレッジ：テストが対象のコードや設定をどの程度カバーしているか
   - 実行時間：テストの実行時間（パフォーマンス監視用）
   - 失敗率：テストの安定性を示す指標

### CDKスナップショットテストの具体的な構造化

AWSインフラコードのテストでは、以下の構造でテスト結果を検証します：

1. **個別リソースの検証**

   ```typescript
   // 特定のリソースタイプと具体的なプロパティを検証
   it("S3バケットの暗号化が正しく設定されている", () => {
     template.hasResourceProperties("AWS::S3::Bucket", {
       BucketEncryption: {
         ServerSideEncryptionConfiguration: [
           {
             ServerSideEncryptionByDefault: {
               SSEAlgorithm: "AES256",
             },
           },
         ],
       },
     });
   });
   ```

2. **リソース数の検証**

   ```typescript
   // リソースの数を明示的に検証
   it("Lambda関数が適切な数だけ作成されている", () => {
     // 「正しく作成されている」ではなく具体的な数を検証
     template.resourceCountIs("AWS::Lambda::Function", 5);
   });
   ```

3. **相互関係の検証**

   ```typescript
   // リソース間の関係性を検証
   it("Lambda関数がS3バケットにアクセスする権限を持っている", () => {
     template.hasResourceProperties("AWS::IAM::Policy", {
       PolicyDocument: {
         Statement: Match.arrayWith([
           Match.objectLike({
             Action: ["s3:GetObject", "s3:PutObject"],
             Resource: {
               "Fn::Join": Match.arrayWith([
                 Match.stringLikeRegexp("arn:aws:s3:::*"),
               ]),
             },
           }),
         ]),
       },
     });
   });
   ```

4. **スナップショット検証**
   ```typescript
   // スタック全体の構造が期待通りか検証
   it("スタックの構造が前回から変更されていない", () => {
     // 意図した変更のみが反映されているか検証
     expect(template.toJSON()).toMatchSnapshot();
   });
   ```

### テスト結果のドキュメント化

テスト結果の解釈と検証プロセスを明確にするため、以下の要素をドキュメント化します：

1. **検証基準書**

   - 各テストカテゴリの具体的な合格基準
   - エッジケースの取り扱い方法
   - テスト実行環境の前提条件

2. **テスト結果レポート**

   - テスト実行結果の構造化された出力
   - 失敗したテストの詳細情報と想定される原因
   - トレンド分析（時間経過による変化）

3. **テスト品質の継続的改善**
   - テストケース自体の品質評価（テストのテスト）
   - 定期的なテストケースのレビューと更新プロセス
   - 新しいテストパターンの採用指針
