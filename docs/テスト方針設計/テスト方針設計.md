# テスト方針設計

## 1. テスト規模（small/medium/large）

テストは、テスト対象の規模や範囲に応じて、small, medium, largeの3つの規模に分けて実施します。これにより、テストの粒度を調整し、効率的に問題を早期に発見することができます。

### smallテスト

- **定義**: smallは単一マシンかつ単一プロセスで実行可能なテストを差します。単一の関数やコンポーネント、APIの一部をテストする小規模なテスト。依存関係は最小限で、単体テストが主に該当します。
- **目的**: 単体の機能が正しく動作するかを確認する。
- **テスト方針**: 単体テストは、特定のモジュールやコンポーネントの動作に集中します。副作用がなく、外部依存が最小限である場合に、このサイズでテストを行います。
  - 使用ツール: Vitest、Storybook
  - 該当するテスト: ユニットテスト、インタラクションテスト、VRT（ビジュアル回帰テスト）

### mediumテスト

- **定義**: mediumは単一マシンかつ複数プロセスで実行可能なテストを差します。サービスやモジュール間の結合をテストする中規模なテスト。複数のコンポーネントやAPIが相互に動作することを確認するテストです。
- **目的**: 複数のコンポーネントやサービスが正しく連携して動作するかを確認する。
- **テスト方針**: 複数のモジュールが連携して動作する場合に行います。APIやデータのフローを確認し、依存関係をテストします。
  - 使用ツール: Vitest、AWS CDK（スナップショットテスト）
  - 該当するテスト: 結合テスト、E2Eテスト

### largeテスト

- **定義**: largeは複数のマシンで実行するテストを差します。システム全体、または大規模なワークフローをテストする規模の大きいテスト。大規模なシステム間の通信や、複数のサービスが複雑に絡み合う場合に行います。
- **目的**: システム全体が正しく動作するか、パフォーマンスやスケーラビリティが問題ないかを確認する。
- **テスト方針**: システム全体の動作をテストするため、負荷テストやスケーラビリティテストを含みます。実際の運用環境に近い形でテストします。
  - 使用ツール: Vitest、Storybook
  - 該当するテスト: E2Eテスト、VRT

## 2. テスト自動化

### テスト自動化のメリット

- **効率化**: 手動で行うよりも迅速にテストを実行できるため、開発サイクルが短縮されます。
- **一貫性**: テストの実行において人為的ミスを減らし、常に一貫した結果を得られます。
- **早期の不具合発見**: 開発中に自動でテストを実行することで、不具合を早期に発見し、修正することができます。
- **回帰テストの簡素化**: 新しいコードが既存の機能に影響を与えないかどうかを確認するのが容易になります。

### テスト自動化を行う際の留意点

- **テストの適切なカバレッジ**: 自動化するテストは、システム全体をカバーするのではなく、重要な部分や頻繁に変更される部分に絞るべきです。
- **テストの安定性**: テスト自動化の対象は、頻繁に変更される部分よりも安定した部分に焦点を当てることが重要です。
- **パフォーマンスの考慮**: 自動化の際には、テスト実行時のパフォーマンスを考慮し、実行速度が遅くなりすぎないようにします。

## 3. テストツール

### フロントエンド

- **Vitest**: 単体テストや統合テストを行うために使用します。モジュールやコンポーネントの動作を確認するために使用します。
- **Storybook**: UIコンポーネントをテストするために使用します。コンポーネントのインタラクションやビジュアルの一貫性を確認するために使用します。

### バックエンド

- **Vitest**: バックエンドのロジックやAPIの動作をテストするために使用します。
- **AWS CDK（スナップショットテスト）**: インフラコードのテストとして、スナップショットテストを実施します。これにより、インフラの変更が適切に反映されているかを確認できます。

## 4. テストのスコープ

### ユニットテスト

- **ツール**: Vitest
- **テスト規模**: Small
- **説明**: モジュールや関数単位で動作確認を行います。外部依存はモック化し、純粋なロジックテストを行います。

### 結合テスト

- **ツール**: Vitest
- **テスト規模**: Medium
- **説明**: 複数のモジュールやサービス間の連携をテストします。APIの呼び出しやデータの流れを確認します。

### E2Eテスト

- **ツール**: Vitest
- **テスト規模**: Large
- **説明**: ユーザーの視点から、システム全体の動作をテストします。UIからバックエンドまで、一連の処理が正しく動作するかを確認します。

### スナップショットテスト

- **ツール**: AWS CDK、Storybook
- **テスト規模**: Medium / Large
- **説明**: コンポーネントやインフラの状態をスナップショットとして保存し、変更があった場合に通知します。

### インタラクションテスト

- **ツール**: Storybook
- **テスト規模**: Small
- **説明**: UIコンポーネントがユーザーのインタラクションに対して正しく反応するかをテストします。

### VRT（ビジュアル回帰テスト）

- **ツール**: Storybook、reg-cli
- **テスト規模**: Medium / Large
- **説明**: UIコンポーネントやページの見た目が期待通りであるかを確認します。ビジュアルの不具合を早期に発見できます。

## 5. テスト結果の定義と構造化

テストがどのような状態で「正しい」と判断するかを客観的かつ明確に定義し、テスト結果を構造化して検証可能にすることが重要です。

### テスト結果の定義基準

テスト結果は以下の基準に基づいて「正しい」と定義します：

1. **明確な期待値の設定**

   - 各テストケースは実行前に具体的な期待値（Expected Value）を明示的に定義する
   - 期待値はコードレビューで確認可能な形で記述する
   - 「正しく作成されている」といった曖昧な表現ではなく、具体的な状態や値を定義する

2. **検証可能な条件**

   - 定性的な評価ではなく、定量的かつ検証可能な条件を設定する
   - 例：「S3バケットが正しく作成されている」ではなく「S3バケットがVersioningEnabledで作成されている」など

3. **決定的なテスト**
   - 同じ条件下で繰り返し実行しても同じ結果が得られること（決定的）
   - 非決定的な要素（タイムスタンプ、乱数など）はモック化または固定値を使用する

### テスト結果の構造化

テスト結果を以下のように構造化して管理します：

1. **カテゴリ分類**

   - 関連するテストケースをグループ化（リソースタイプ、機能単位など）
   - 各カテゴリはドメイン知識に基づいた意味のある単位とする

2. **検証レベルの階層化**

   - プロパティレベル：リソースの個別プロパティが期待通りか
   - リソースレベル：リソース全体の構成が期待通りか
   - スタックレベル：複数リソース間の関係が期待通りか

3. **メトリクス収集**
   - カバレッジ：テストが対象のコードや設定をどの程度カバーしているか
   - 実行時間：テストの実行時間（パフォーマンス監視用）
   - 失敗率：テストの安定性を示す指標

### CDKスナップショットテストの具体的な構造化

AWSインフラコードのテストでは、以下の構造でテスト結果を検証します：

1. **個別リソースの検証**

   ```typescript
   // 特定のリソースタイプと具体的なプロパティを検証
   it("S3バケットの暗号化が正しく設定されている", () => {
     template.hasResourceProperties("AWS::S3::Bucket", {
       BucketEncryption: {
         ServerSideEncryptionConfiguration: [
           {
             ServerSideEncryptionByDefault: {
               SSEAlgorithm: "AES256",
             },
           },
         ],
       },
     });
   });
   ```

2. **リソース数の検証**

   ```typescript
   // リソースの数を明示的に検証
   it("Lambda関数が適切な数だけ作成されている", () => {
     // 「正しく作成されている」ではなく具体的な数を検証
     template.resourceCountIs("AWS::Lambda::Function", 5);
   });
   ```

3. **相互関係の検証**

   ```typescript
   // リソース間の関係性を検証
   it("Lambda関数がS3バケットにアクセスする権限を持っている", () => {
     template.hasResourceProperties("AWS::IAM::Policy", {
       PolicyDocument: {
         Statement: Match.arrayWith([
           Match.objectLike({
             Action: ["s3:GetObject", "s3:PutObject"],
             Resource: {
               "Fn::Join": Match.arrayWith([
                 Match.stringLikeRegexp("arn:aws:s3:::*"),
               ]),
             },
           }),
         ]),
       },
     });
   });
   ```

4. **スナップショット検証**
   ```typescript
   // スタック全体の構造が期待通りか検証
   it("スタックの構造が前回から変更されていない", () => {
     // 意図した変更のみが反映されているか検証
     expect(template.toJSON()).toMatchSnapshot();
   });
   ```

### テスト結果のドキュメント化

テスト結果の解釈と検証プロセスを明確にするため、以下の要素をドキュメント化します：

1. **検証基準書**

   - 各テストカテゴリの具体的な合格基準
   - エッジケースの取り扱い方法
   - テスト実行環境の前提条件

2. **テスト結果レポート**

   - テスト実行結果の構造化された出力
   - 失敗したテストの詳細情報と想定される原因
   - トレンド分析（時間経過による変化）

3. **テスト品質の継続的改善**
   - テストケース自体の品質評価（テストのテスト）
   - 定期的なテストケースのレビューと更新プロセス
   - 新しいテストパターンの採用指針
